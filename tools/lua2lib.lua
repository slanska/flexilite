---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by slanska.
--- DateTime: 2018-06-12 6:27 PM
---

--[[
Command line utility to compile list of .lua files to .obj format (using luajit -b)
and then bundle all files to a static library to be linked with C/C++ project
]]

if not jit then
    error 'This script has to be run by LuaJIT, not regular Lua'
end

local os = require 'os'
local path = require 'pl.path'
local lapp = require 'pl.lapp'
local stringx = require 'pl.stringx'
local pretty = require 'pl.pretty'
local pl_file = require 'pl.file'

local startTime = os.clock()

-- set lua paths
local paths = {
    '../lib/debugger-lua/?.lua',
    '../lib/lua-ansicolors/?.lua',
    './lib/lua-ansicolors/?.lua',
    '../?.lua',
}

for _, pp in ipairs(paths) do
    package.path = path.abspath(path.relpath(pp)) .. ';' .. package.path
end

local ansicolors = require 'ansicolors'

local cli_args = lapp [[
Compile lua-to-static-library
<filelist> (string)  Path to file list .lua module
    -n, --name (string default 'luaModules.a')  Name of target library
    -o, --output (string default 'obj_lua')  Output path
    -f, --force Force rebuild
]]

---@param cmd string
local function os_execute(cmd)
    local result, _, code = os.execute(cmd)
    if result == nil then
        error(string.format('Error executing command [%s]: code %s', cmd, code))
    end
end

local file_list = path.abspath(path.relpath(cli_args.filelist))

local files = loadfile(file_list)()

local libName = path.splitext(path.basename(cli_args.name))

local out_path = path.join(path.abspath(cli_args.output), libName)

if not path.exists(out_path) then
    if jit.os == 'Windows' then
        os.execute(string.format('mkdir "%s"', out_path))
    else
        os.execute(string.format('mkdir -p "%s"', out_path))
    end
end

local cfg = {}

-- Load previous stats (if exists)
local cfgFilePath = path.join(out_path, '.lua2lib')
local cfgFile = io.open(cfgFilePath, 'r')
if cfgFile ~= nil then
    local cfgStr = cfgFile:read("*all")
    cfg = pretty.read(cfgStr)
    cfgFile:close()
end

local function lastModified(filePath)
    local result = pl_file.modified_time(filePath)
    return result
end

local there_are_changes = false

local files_processed = 0
local files_skipped = 0

-- Process file list
for module_name, file_name in pairs(files) do

    files_processed = files_processed + 1

    -- Compile .lua file
    local nn = ''
    if type(file_name) ~= 'number'
            and type(module_name) == 'string' and module_name ~= '' then
        nn = 'n ' .. module_name
    else
        file_name = module_name
    end

    local cmd

    -- Current directory is expected to be flexilite
    local file_path = path.abspath(path.relpath(file_name))
    local _, ext = path.splitext(file_path)

    --local newMd5 = calcMD5(file_path)
    local last_modified = lastModified(file_path)
    local process_this_file = false

    -- Analyze if file has changed since last processing
    local prev_modified = cfg[module_name]
    if cli_args.force or prev_modified == nil or prev_modified ~= last_modified then
        process_this_file = true
        there_are_changes = true
    end

    cfg[module_name] = last_modified

    if process_this_file then
        if ext ~= '.lua' then
            -- Non Lua files are treated as string resources (e.g. SQL files)
            -- Read file content
            local in_file = io.open(file_path, 'r')
            local res_str = in_file:read("*all")
            in_file:close()

            -- Encode it as string
            local code = string.format('return %s', stringx.quote_string(res_str))

            -- Save as temp file
            local file_path = os.tmpname()
            local tmp_file = io.open(file_path, 'w')

            tmp_file:write(code)
            tmp_file:close()

            -- Compile to .o
            local o_file = path.abspath(path.join(out_path, path.relpath(
                    string.gsub(string.gsub(file_name, '/', '.'),
                            '%.%.%.', '') .. '.o')))

            cmd = string.format('luajit -b%s "%s" "%s"',
                    nn, file_path, o_file)

            print(ansicolors(string.format('%%{magenta}%s: compiling %s%%{reset}', libName, file_name)))

            os_execute(cmd)

            --Delete temp file
            os.remove(file_path)
        else
            -- Compile to .o
            local o_file = path.abspath(path.join(out_path, path.relpath(
                    string.gsub(string.gsub(file_name, '/', '.'),
                            '%.%.%.', '') .. '.o')))
            cmd = string.format('luajit -bg%s  "%s" "%s"',
                    nn, file_path, o_file)

            print(ansicolors(string.format('%%{yellow}%s: compiling %s%%{reset}', libName, file_name)))

            os_execute(cmd)
        end
    else
        files_skipped = files_skipped + 1
    end
end

-- Save updated config
if there_are_changes then
    cfgFile = io.open(cfgFilePath, 'w+')
    if cfgFile ~= nil then
        local cfgStr = pretty.write(cfg)
        cfg = cfgFile:write(cfgStr)
        cfgFile:close()
    end

    -- Bundle library into single archive
    if jit.os == 'Windows' then
        -- Use Visual Studio LIB tool to build static ibrary
        local cmd = string.format('lib  -nologo -out:%s %s/*.o', path.join(out_path, cli_args.name), out_path)
        os_execute(cmd)
    else
        -- *NIX (e.g. Linux and macOS) - use AR for building static library
        local cmd = string.format('ar rcus %s %s/*.o', path.join(out_path, cli_args.name), out_path)
        os_execute(cmd)
    end
else
    print(ansicolors(string.format('%%{yellow}%s: no changes detected%%{reset}', libName)))
end

print(ansicolors(string.format('%%{magenta}%s: completed in %s sec(s). %d file(s) processed, %d file(s) skipped.%%{reset}',
        libName, os.clock() - startTime, files_processed, files_skipped)))
