---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by slanska.
--- DateTime: 2018-01-12 5:37 PM
---

--[[
DBProperty and derived classes.
Used by DBObject/*DBOV to access object property values

Provides access to Boxed(), to be called from custom scripts and functions
Hold list of DBValue items, one item per .ref-value row (or A..P columns in .objects row)
]]

local class = require 'pl.class'
local DBValue = require 'DBValue'
local tablex = require 'pl.tablex'
local Constants = require 'Constants'
local JSON = cjson or require 'cjson'

local table_insert = table.insert

---@class PropertySaveContext
---@field PropDef PropertyDef
---@field PropIdx number

-------------------------------------------------------------------------------
--[[
DBProperty
Provides access to simple values (both scalar and vector)
]]
-------------------------------------------------------------------------------
---@class DBProperty
---@field DBOV ReadOnlyDBOV @comment DB Object Version
---@field PropDef PropertyDef
local DBProperty = class()

---@class DBPropertyBoxed: DBValueBoxed
local DBPropertyBoxed = class(DBValue.BoxedClass)

function DBPropertyBoxed:getValue1()
    local vv = self.Prop:GetValue(1)
    if vv then
        return vv.Value
    end
    return DBValue.Null
end

---@param prop DBProperty
function DBPropertyBoxed:_init(prop)
    self:super(DBPropertyBoxed.getValue1, prop, 1)
end

function DBPropertyBoxed:__index(key)
    if type(key) == 'number' then
        local vv = self:GetValue(key)
        if vv then
            return vv.Boxed(self, key)
        end
        return DBValue.Null
    elseif type(key) == 'string' then
        -- todo
        -- ref object property
    else
        --
    end
end

function DBPropertyBoxed:__newindex(key, value)
    return self:SetValue(key, value)
end

function DBPropertyBoxed:__len(self, v1)

end

---@param DBOV ReadOnlyDBOV
---@param propDef PropertyDef
function DBProperty:_init(DBOV, propDef)
    self.DBOV = assert(DBOV)
    self.PropDef = assert(propDef)
end

function DBProperty:Boxed()
    if not self.boxed then
        self.boxed = DBPropertyBoxed(self)
    end

    return self.boxed
end

---@param idx number @comment 1 based index
---@param val any
function DBProperty:SetValue(idx, val)
    error(string.format('Cannot modify readonly version of %s',
            self.PropDef:debugDesc()))
end

---@param idx number @comment 1 based
---@return DBValue
function DBProperty:GetValue(idx)
    self.PropDef.ClassDef.DBContext.AccessControl:ensureCurrentUserAccessForProperty(
            self.PropDef.ID, Constants.OPERATION.READ)

    idx = idx or 1

    if not self.values then
        self.values = {}
    end

    ---@type DBValue
    local v = self.values[idx]

    if v then
        return v
    end

    -- load from db
    local sql = [[select * from [.ref-values]
            where ObjectID = :ObjectID and PropertyID = :PropertyID and PropIndex <= :PropIndex
            order by ObjectID, PropertyID, PropIndex;]]
    for row in self.DBOV.ClassDef.DBContext:loadRows(sql, { ObjectID = self.DBOV.ID,
                                                            PropertyID = self.PropDef.ID, PropIndex = idx }) do
        -- TODO what if index 1 is set in .ref-values and in .objects[A..P]? Override? Ignore?
        table_insert(self.values, row.PropIndex, DBValue(row))
    end

    if not self.values[idx] then
        return DBValue.Null
    end

    return self.values[idx]
end

-- Returns all values as array or scalar value (depending on property's maxOccurrences)
-- Values are returned in user-friendly format (e.g. blobs as base64 strings)
function DBProperty:GetValues()
    local maxOccurr = (self.PropDef.D and self.PropDef.D.rules and self.PropDef.D.rules.maxOccurrences) or 1
    if maxOccurr > 1 then
        local result = {}
        if self.values then
            for
            ---@type number
            ii,
            ---@type DBValue
            dbv in pairs(self.values) do
                -- TODO Handle references
                table_insert(result, ii, dbv.Value)
            end
        end
        return result
    else
        return self:GetValue(1).Value
    end
end

---@param idx number
---@return DBValue
function DBProperty:cloneValue(idx)
    return tablex.deepcopy(assert(self.values[idx]))
end

--
function DBProperty:ExportValues()
    if self.values == nil then
        return nil
    end

    if self.PropDef.D.rules.maxOccurrences then

    end

    local result = {}
    for _, dbv in ipairs(self.values) do
        table_insert(result, self.PropDef:ExportDBValue(self.DBOV.DBObject, dbv))
    end
    return result
end

-------------------------------------------------------------------------------
--[[
ChangedDBProperty
Used by WritableDBOV (DBObject.curVer)
]]
-------------------------------------------------------------------------------
---@class ChangedDBProperty @parent DBProperty
---@field DBOV WritableDBOV
---@field PropDef PropertyDef
---@field values table<number, DBValue>
---@field appendIndex number @comment auto-decrement value used for appended values
local ChangedDBProperty = class(DBProperty)

function ChangedDBProperty:_init(DBOV, propDef)
    self:super(DBOV, propDef)
end

-- Internal method to get access to original counterpart property
---@return DBProperty | nil
function ChangedDBProperty:getOriginalProperty()
    if self.DBOV.DBObject.state == Constants.OPERATION.CREATE then
        return nil
    end
    local result = self.DBOV.DBObject.origVer:getProp(self.PropDef.Name.text)
    if not result then
        error(string.format('DBProperty %s not found',
                self.PropDef:debugDesc()))
    end
    return result
end

---@param idx number @comment > 1 (1-based index) or 0 or < 0 or nil -> append mode
---@param val any
function ChangedDBProperty:SetValue(idx, val)
    -- Short reference for better performance
    ---@type DBContext
    local DBContext = self.PropDef.ClassDef.DBContext

    local maxOccurr = self.PropDef.D.rules.maxOccurrences or Constants.MAX_INTEGER
    if idx > maxOccurr then
        error(string.format('%s: maxOccurrences rule violation (%d > %d)',
                self.PropDef:debugDesc(), idx, maxOccurr))
    end

    if not self.values then
        self.values = {}
    end

    if idx <= 0 or idx == nil then
        idx = (self.appendIndex or 0) - 1
        self.appendIndex = idx
    end

    ---@type DBValue
    local result = self.values[idx]
    if not result then
        DBContext.AccessControl:ensureCurrentUserAccessForProperty(
                self.PropDef.ID, self.DBOV.DBObject.state)
        local prop = self:getOriginalProperty()
        if prop then
            result = prop:cloneValue(idx)
        else
            result = DBValue {  }
        end
        self.values[idx] = result
    end

    if result then
        result.deferredSaveAction = self.PropDef:ImportDBValue(result, val)
    else
        DBContext.AccessControl:ensureCurrentUserAccessForProperty(
                self.PropDef.ID, idx == 1 and Constants.OPERATION.UPDATE or Constants.OPERATION.CREATE)
        -- is not set - create new one
        result = DBValue { Value = val }
        self.values[idx] = result
    end
end

---@param idx number @comment 1 based index
---@return DBValue
function ChangedDBProperty:GetValue(idx)
    idx = idx or 1

    if not self.values or not self.values[idx] then
        local orig = self:getOriginalProperty()
        if orig then
            local vv = orig.GetValue
            if vv then
                return vv(self, idx)
            end
        end
        return DBValue.Null
    end

    return self.values[idx]
end

-- Updates ctlv value of DBValue, in according to PropDef definition and current Value
---@param dbv DBValue
function ChangedDBProperty:updateCTLV(dbv)
    -- TODO
end

-- Sorts property values by index
-- TODO
local function sort_values(values)
    tablex.sort(tablex.keys(values), function(a, b)
        if a > 0 and b > 0 then
            return a < b
        elseif a < 0 and b < 0 then
            return a > b
        else
            return a > 0 and b < 0
        end
    end)
end

-- Saves values to the database
---@param ctx PropertySaveContext
function ChangedDBProperty:SaveToDB(ctx)
    -- Local copy for better performance
    ---@type DBContext
    local DBContext = self.DBOV.ClassDef.DBContext

    if not self.values then
        return
    end

    ctx.PropDef = self.PropDef

    local op = self.DBOV.DBObject.state
    ---@type DBProperty
    local orig_prop
    if op == Constants.OPERATION.CREATE then
        orig_prop = self
    else
        orig_prop = self.DBOV.DBObject.origVer:getProp(self.PropDef.Name.text) or self
    end

    local propCtlv = self.PropDef:GetCTLV()

    local valWrapper = ':Value'
    local nativeType = self.PropDef:getNativeType()
    if nativeType ~= nil and nativeType ~= '' then
        valWrapper = string.format('cast(:Value as %s)', nativeType)
    end

    ---@param idx number
    ---@param dbv DBValue
    local function saveDBValue(idx, dbv)
        ctx.PropIdx = idx
        if idx == 1 then
            -- Check if there is column mapping
            -- TODO
        end

        if op == Constants.OPERATION.CREATE then
            if dbv.Value ~= nil then
                --  insert
                local params = {
                    ObjectID = self.DBOV.ID,
                    PropertyID = self.PropDef.ID,
                    PropIndex = idx,
                    Value = dbv.Value,
                    ctlv = propCtlv,
                    MetaData = dbv.MetaData and JSON.encode(dbv.MetaData) or nil }

                if idx < 0 then
                    -- Append new value
                    DBContext:execStatement(string.format(
                    ---@language sqlite
                            [[insert into [.ref-values]
                    (ObjectID, PropertyID, PropIndex, [Value], ctlv, MetaData) values
                    (:ObjectID, :PropertyID,
                    coalesce((select max(PropIndex) from [.ref-values] where ObjectID = :ObjectID and PropertyID = :PropertyID limit 1), 0) + 1,
                    %d, :ctlv, :MetaData);]], valWrapper)
                    , params)
                else
                    -- Add or update value with known index
                    DBContext:execStatement(string.format([[insert into [.ref-values]
                    (ObjectID, PropertyID, PropIndex, [Value], ctlv, MetaData) values
                    (:ObjectID, :PropertyID, :PropIndex, %s, :ctlv, :MetaData);]], valWrapper)
                    , params)
                end

            end
        else
            if dbv.Value == nil then
                -- Delete
                DBContext:execStatement([[delete from [.ref-values]
                where ObjectID=:old_ObjectID and PropertyID=:old_PropertyID
                and PropIndex=:old_PropIndex;]],
                        { old_ObjectID = orig_prop.DBOV.ID,
                          old_PropertyID = orig_prop.PropDef.ID,
                          old_PropIndex = idx })
            else

                if self ~= orig_prop and (self.DBOV.ID ~= orig_prop.DBOV.ID or self.PropDef.ID ~= orig_prop.PropDef.ID) then
                    -- Extended update - object ID and/or property ID have changed
                    -- TODO
                else
                    -- Regular insert/update
                    local params = {
                        ObjectID = self.DBOV.ID,
                        PropertyID = self.PropDef.ID,
                        PropIndex = idx,
                        Value = dbv.Value,
                        ctlv = propCtlv,
                        MetaData = dbv.MetaData and JSON.encode(dbv.MetaData) or nil }

                    if idx < 0 then
                        -- Append new value
                        DBContext:execStatement(([[insert or replace into [.ref-values]
                    (ObjectID, PropertyID, PropIndex, [Value], ctlv, MetaData) values
                    (:ObjectID, :PropertyID,
                    coalesce((select max(PropIndex) from [.ref-values] where ObjectID = :ObjectID and PropertyID = :PropertyID limit 1), 0) + 1,
                    %s, :ctlv, :MetaData);]]):format(valWrapper), params)
                    else
                        -- Add or update value with known index
                        DBContext:execStatement(([[insert or replace into [.ref-values]
                    (ObjectID, PropertyID, PropIndex, [Value], ctlv, MetaData) values
                    (:ObjectID, :PropertyID, :PropIndex, %s, :ctlv, :MetaData);]]):format(valWrapper), params)
                    end
                end
            end
        end
    end

    for idx, dbv in pairs(self.values) do
        if dbv.deferredSaveAction ~= nil then
            DBContext.ActionQueue:enqueue(function(params)
                params.dbv.deferredSaveAction()
                saveDBValue(params.idx, params.dbv)
            end, { dbv = dbv, idx = idx })
        else
            saveDBValue(idx, dbv)
        end
    end
end

return {
    DBProperty = DBProperty,
    ChangedDBProperty = ChangedDBProperty,
}
